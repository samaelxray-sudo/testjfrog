name: Build (parallel) + Publish single build-info + Xray reports

on:
  workflow_dispatch:
  push:
    branches: [ main ]

env:
  JF_URL: ${{ secrets.JF_URL }}
  JF_USER: ${{ secrets.JF_USER }}
  JF_PASSWORD: ${{ secrets.JF_PASSWORD }}
  BUILD_NAME: new-build
  BUILD_NUMBER: ${{ github.run_number }}
  DOCKER_REPO: test-docker-local

jobs:
  build:
    name: Build & push ${{ matrix.service }}
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        service: [ "service1", "service2", "service3" ] # <-- reemplaza por tu lista dinámica si procede
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup JFrog CLI
        uses: jfrog/setup-jfrog-cli@v4

      - name: Configure JFrog
        shell: bash
        run: |
          set -euo pipefail
          jf c add --url "$JF_URL" --user "$JF_USER" --password "$JF_PASSWORD" --interactive=false

      - name: Docker login
        shell: bash
        run: |
          set -euo pipefail
          echo "$JF_PASSWORD" | docker login "$JF_URL" -u "$JF_USER" --password-stdin

      - name: Build & push image
        shell: bash
        run: |
          set -euo pipefail
          IMAGE="${{ matrix.service }}"
          TAG="$BUILD_NUMBER"
          # Si tu Dockerfile está en subcarpeta ./<service>, mantenlo así. Si no, ajusta el contexto.
          docker build -t "$JF_URL/$DOCKER_REPO/$IMAGE:$TAG" "$IMAGE"
          docker push "$JF_URL/$DOCKER_REPO/$IMAGE:$TAG"

      - name: Add image to build-info (module)
        shell: bash
        run: |
          set -euo pipefail
          IMAGE="${{ matrix.service }}"
          TAG="$BUILD_NUMBER"

          # Obtener digest del manifest
          MANIFEST_DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' "$JF_URL/$DOCKER_REPO/$IMAGE:$TAG" | cut -d'@' -f2)
          echo "$JF_URL/$DOCKER_REPO/$IMAGE:$TAG@$MANIFEST_DIGEST" > image.txt

          # Registrar el módulo en build-info local del runner
          jf rt bdc "$DOCKER_REPO" \
            --image-file=image.txt \
            --build-name="$BUILD_NAME" \
            --build-number="$BUILD_NUMBER" \
            --module="$IMAGE"

      - name: Collect env for this module
        shell: bash
        run: |
          set -euo pipefail
          jf rt bce "$BUILD_NAME" "$BUILD_NUMBER"

      - name: Export module build-info (dry-run)
        shell: bash
        run: |
          set -euo pipefail
          IMAGE="${{ matrix.service }}"
          jf rt bp "$BUILD_NAME" "$BUILD_NUMBER" --dry-run | tee "buildinfo-$IMAGE.json"

          # Extraer ÚNICAMENTE el módulo de este servicio en un JSON autocontenido:
          jq --arg bn "$BUILD_NAME" --arg bno "$BUILD_NUMBER" \
             '{name:$bn, number:$bno, modules:[ .modules[0] ]}' \
             "buildinfo-$IMAGE.json" > "module-$IMAGE.json"

      - name: Upload module JSON
        uses: actions/upload-artifact@v4
        with:
          name: jfrog-modules
          path: module-*.json

  publish:
    name: Merge modules & publish build-info + Xray
    runs-on: ubuntu-latest
    needs: [ build ]
    steps:
      - name: Download module JSONs
        uses: actions/download-artifact@v4
        with:
          name: jfrog-modules
          path: modules
          merge-multiple: true

      - name: Show downloaded files
        shell: bash
        run: |
          set -euo pipefail
          ls -la modules
          jq --version

      - name: Setup JFrog CLI
        uses: jfrog/setup-jfrog-cli@v4

      - name: Configure JFrog
        shell: bash
        run: |
          set -euo pipefail
          jf c add --url "$JF_URL" --user "$JF_USER" --password "$JF_PASSWORD" --interactive=false

      - name: Merge all modules into one build-info
        id: merge
        shell: bash
        run: |
          set -euo pipefail
          cd modules

          # Validar que hay módulos
          ls module-*.json >/dev/null 2>&1 || { echo "❌ No hay módulos"; exit 1; }

          # Construir build-info consolidado con todos los módulos
          jq -s \
            --arg name "$BUILD_NAME" \
            --arg num "$BUILD_NUMBER" \
            '{
              version:"1.0.1",
              name:$name,
              number:$num,
              modules: (map(.modules[0]))
            }' module-*.json > consolidated-buildinfo.json

          echo "Consolidated build-info:"
          jq . consolidated-buildinfo.json

      - name: Publish consolidated build-info to Artifactory
        shell: bash
        run: |
          set -euo pipefail
          cd modules
          # Publicar directamente por API (equivalente a /api/build)
          jf rt curl -XPUT "/api/build" \
            -H "Content-Type: application/json" \
            -T consolidated-buildinfo.json

      - name: Trigger Xray scan for this build
        shell: bash
        run: |
          set -euo pipefail
          jf xr curl -XPOST "/api/v2/ci/build" \
            -H "Content-Type: application/json" \
            -d "{\"build_name\":\"$BUILD_NAME\",\"build_number\":\"$BUILD_NUMBER\"}"

      # ===== Vulnerabilities Report (opcional) =====
      - name: Create vulnerabilities report
        id: vuln
        shell: bash
        run: |
          set -euo pipefail
          REPORT_NAME="vuln-$BUILD_NAME-$BUILD_NUMBER-$(date +%s)"
          read -r -d '' BODY <<EOF
          {
            "name": "$REPORT_NAME",
            "resources": {
              "builds": {
                "names": ["$BUILD_NAME"],
                "number_of_latest_versions": 1
              }
            },
            "filters": {
              "severities": ["Critical","High","Medium","Low"]
            }
          }
          EOF

          echo "Payload:"
          echo "$BODY"
          RESP=$(jf xr curl -XPOST "/api/v1/reports/vulnerabilities" \
                  -H "Content-Type: application/json" -d "$BODY")
          echo "Raw response: $RESP" | tee resp.json

          RID=$(echo "$RESP" | jq -r '.report_id // empty')
          if [ -z "$RID" ]; then
            echo "❌ Error creating vulnerabilities report"
            exit 1
          fi
          echo "report_id=$RID" >> "$GITHUB_OUTPUT"

      - name: Download vulnerabilities report
        shell: bash
        run: |
          set -euo pipefail
          RID="${{ steps.vuln.outputs.report_id }}"
          jf xr curl -XGET "/api/v1/reports/vulnerabilities/$RID/download" --output vuln-report.json
          cat vuln-report.json | jq > vuln-report.pretty.json

      # ===== SBOM (CycloneDX) =====
      - name: Generate SBOM (CycloneDX)
        shell: bash
        run: |
          set -euo pipefail
          jf xr curl -XPOST "/api/v1/sbomExport" \
            -H "Content-Type: application/json" \
            -d "{
              \"export_format\": \"cyclonedx\",
              \"resources\": {
                \"builds\": [
                  { \"name\": \"$BUILD_NAME\", \"number\": \"$BUILD_NUMBER\" }
                ]
              }
            }" \
            --output sbom.json

      - name: Upload reports
        uses: actions/upload-artifact@v4
        with:
          name: reports
          path: |
            modules/consolidated-buildinfo.json
            vuln-report.json
            vuln-report.pretty.json
            sbom.json
