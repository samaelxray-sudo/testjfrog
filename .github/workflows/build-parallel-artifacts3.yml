name: Third WF Parallel Artifacts

on:
  push:
    branches:
      - main
    paths:
      - .github/workflows/build-parallel-artifacts3.yml
jobs:
  discover-services:
    runs-on: ubuntu-latest
    outputs:
      services: ${{ steps.set-services.outputs.services }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Discover services dynamically
        id: set-services
        run: |
          # üîΩ Aqu√≠ calculas tu lista din√°micamente
          SERVICES="image-1 image-2 image-3"

          # Convertimos la lista a JSON: ["image-1","image-2","image-3"]
          SERVICES_JSON=$(printf '["%s"]' "$(echo $SERVICES | sed 's/ /","/g')")

          echo "services=$SERVICES_JSON" >> $GITHUB_OUTPUT
          echo "Discovered services: $SERVICES_JSON"

  build:
    name: Build ${{ matrix.service }}
    runs-on: ubuntu-latest
    needs: discover-services
    strategy:
      matrix:
        image: ${{ fromJson(needs.discover-services.outputs.services) }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup JFrog CLI
        uses: jfrog/setup-jfrog-cli@v4
        env:
          JF_URL: ${{ vars.JF_URL }}
          JF_ACCESS_TOKEN: ${{ secrets.JF_ACCESS_TOKEN }}

      - name: Build and Push Docker image
        env:
          IMAGE_NAME: samaelxray.jfrog.io/test-docker-local/${{ matrix.image }}:${{ github.run_number }}
        run: |
          echo "Building $IMAGE_NAME"
          jf docker login samaelxray.jfrog.io -u samaelxray@gmail.com -p ${{ secrets.JF_ACCESS_TOKEN }}
          jf docker build -t $IMAGE_NAME ./microservices/${{ matrix.image }}
          jf docker push $IMAGE_NAME

      - name: Create image-file.txt with digest
        env:
          IMAGE_NAME: samaelxray.jfrog.io/test-docker-local/${{ matrix.image }}:${{ github.run_number }}
        run: |
          # 3) Obtener el digest del MANIFEST (l√≠nea esperada por bdc: '<IMAGE>@sha256:<MANIFEST>')
          DIGEST="$(docker buildx imagetools inspect "${IMAGE_NAME}" | awk '/Digest:/ {print $2; exit}')"
          if [ -z "${DIGEST}" ]; then
            echo "No pude obtener el digest del manifest de ${IMAGE}"
            exit 1
          fi
          echo "/************ Image ***********/"
          echo "${IMAGE_NAME}@${DIGEST}"
          echo "${IMAGE_NAME}@${DIGEST}" > image.txt

      - name: Add Docker image to Build Info
        run: |
          # 4) Registrar el m√≥dulo docker EN LOCAL en la misma build
          #    (OJO: sintaxis correcta de 2.78.3: --image-file y al final el <target repo>)
          jf rt bdc \
            --image-file=image.txt \
            --build-name=new-build \
            --build-number=${{ github.run_number }} \
            --module=${{ matrix.image }} \
            test-docker-local

          # (Opcional) Variables de entorno/VCS si quieres que salgan en la build:
          # jf rt bce "${BUILD_NAME}" "${BUILD_NUMBER}"
          # jf rt bag "${BUILD_NAME}" "${BUILD_NUMBER}" || true   # solo si hay .git, si no, ignora

          # 5) Sacar el JSON previo de ESTA build local (contiene SOLO el m√≥dulo de este servicio)
          mkdir -p jfrog-parts
          echo "Sacar el JSON previo de ESTA build local (contiene SOLO el m√≥dulo de este servicio)"
          jf rt bp new-build ${{ github.run_number }} --dry-run > "jfrog-parts/${{ matrix.image }}.json"
          cat jfrog-parts/${{ matrix.image }}.json

          # 6) Subir el JSON como artefacto del job (actions/upload-artifact@v4)
      - name: Upload partial build-info
        uses: actions/upload-artifact@v4
        with:
          name: jfrog-part-${{ matrix.image }}   # nombre √∫nico por servicio
          path: jfrog-parts/${{ matrix.image }}.json
          retention-days: 1                        # opcional, se borran r√°pido

  merge:
    name: Merge build-infos and publish
    runs-on: ubuntu-latest
    needs: [discover-services, build]    

    steps:
      - uses: actions/checkout@v4

      - name: Setup JFrog CLI
        uses: jfrog/setup-jfrog-cli@v4
        env:
          JF_URL: ${{ vars.JF_URL }}
          JF_ACCESS_TOKEN: ${{ secrets.JF_ACCESS_TOKEN }}

      - name: Download parts
        uses: actions/download-artifact@v4
        with:
          pattern: jfrog-part-*
          merge-multiple: true

      - name: Merge modules
        run: |
          jq -s '{
            name:       (.[0].name),
            number:     (.[0].number),
            started:    (.[0].started),
            url:        (.[0].url),
            agent:      (.[0].agent),
            buildAgent: (.[0].buildAgent),
            properties: (reduce .[].properties as $p ({}; . * ($p // {}))),
            modules:    (map(.modules) | add)
          }' *.json > merged.json

      - name: Publish build-info
        run: |
          jf rt curl -X PUT "/api/build" \
            -H "Content-Type: application/json" \
            -T merged.json
            
      - name: Xray scan (JSON) y SBOM (CycloneDX)
        env:
          BUILD_NAME: new-build
          BUILD_NUMBER: ${{ github.run_number }}
        run: |
          # Reporte de seguridad (JSON) 
          jf bs "$BUILD_NAME" "$BUILD_NUMBER" --vuln --format=json --fail=false > build-security.json

          # SBOM en formato CycloneDX (JSON)
          jf bs "$BUILD_NAME" "$BUILD_NUMBER" --format=cyclonedx --fail=false > build-sbom.cdx.json
      
      - name: Subir artefactos (reporte y SBOM)
        uses: actions/upload-artifact@v4
        with:
          name: "${{ env.BUILD_NAME }}-${{ env.BUILD_NUMBER }}-xray-and-sbom"
          path: |
            build-security.json
            build-sbom.cdx.json
          retention-days: 14

      - name: Resumen r√°pido en el Job Summary
        env:
          BUILD_NAME: new-build
          BUILD_NUMBER: ${{ github.run_number }}
        run: |
          {
            echo "### Xray para $BUILD_NAME/$BUILD_NUMBER";
            echo "- Reporte (JSON): \`build-security.json\`";
            echo "- SBOM CycloneDX (JSON): \`build-sbom.cdx.json\`";
          } >> "$GITHUB_STEP_SUMMARY"

  security-report:
    name: Generate Security Report & SBOM
    runs-on: ubuntu-latest
    needs: [discover-services, build, merge]   # depende del job donde publicas y escaneas la build
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup JFrog CLI
        uses: jfrog/setup-jfrog-cli@v4
        env:
          JF_URL: ${{ vars.JF_URL }}
          JF_ACCESS_TOKEN: ${{ secrets.JF_ACCESS_TOKEN }}

      - name: Ensure out dir
        run: mkdir -p reports
      
      # 1) (Opcional) Forzar escaneo de la build por Xray - V2
      - name: Trigger Xray scan (optional)
        env:
          BUILD_NAME: new-build
          BUILD_NUMBER: ${{ github.run_number }}
        run: |
          jf xr curl -XPOST /api/v2/ci/build \
            -H "Content-Type: application/json" \
            -d "{\"build_name\":\"${BUILD_NAME}\",\"build_number\":\"${BUILD_NUMBER}\"}" | jq .
      
      # 2) Vulnerabilities Report (API v1) -> Export PDF
      - name: Create vulnerabilities report
        id: vuln_report
        env:
          BUILD_NAME: new-build
          BUILD_NUMBER: ${{ github.run_number }}
        run: |
          body=$(cat <<EOF
          {
            "name": "report-${BUILD_NAME}-${BUILD_NUMBER}",
            "resources": {
              "builds": {
              "names": ["${BUILD_NAME}"],
                "include_patterns": ["${BUILD_NUMBER}"],
                "number_of_latest_versions": 1
              }
            },
            "filters": {
              "severities": ["Critical","High","Medium","Low"]
            }
          }
          EOF
          )

          echo "Request body:"
          echo "$body" | jq .

          resp=$(jf xr curl -XPOST /api/v1/reports/vulnerabilities \
                    -H "Content-Type: application/json" \
                    -d "$body")
      
          echo "Raw response: $resp" | tee resp.json
      
          err=$(echo "$resp" | jq -r '.error? // empty')
          if [ -n "$err" ]; then
            echo "‚ùå Error creating vulnerabilities report: $err" >&2
            exit 1
          fi

          rid=$(echo "$resp" | jq -r '.report_id?')
          if [ -z "$rid" ] || [ "$rid" = "null" ]; then
            echo "‚ùå No report_id found in response" >&2
            cat resp.json
            exit 1
          fi

          echo "‚úÖ Report created with id: $rid"
          echo "rid=$rid" >> $GITHUB_OUTPUT

      - name: Wait until report is completed
        env:
          BUILD_NAME: new-build
          BUILD_NUMBER: ${{ github.run_number }}
        run: |
          rid="${{ steps.vuln_report.outputs.rid }}"
          echo "Waiting for report $rid ..."
          for i in {1..60}; do
            status=$(jf xr curl -XGET "/api/v1/reports/${rid}" | jq -r .status)
            echo "Status: $status"
            if [ "$status" = "completed" ]; then
              break
            fi
            if [ "$status" = "failed" ]; then
              echo "Report failed" >&2
              exit 1
            fi
            sleep 5
          done

      - name: Export vulnerabilities report as PDF
        env:
          BUILD_NAME: new-build
          BUILD_NUMBER: ${{ github.run_number }}
        run: |
          rid="${{ steps.vuln_report.outputs.rid }}"
          # Export: devuelve application/zip u octet-stream; si pides PDF te entrega un PDF dentro del ZIP o PDF directo seg√∫n tama√±o.
          jf xr curl -XGET "/api/v1/reports/export/${rid}?format=pdf&file_name=${BUILD_NAME}-${BUILD_NUMBER}-vuln" > "reports/${BUILD_NAME}-${BUILD_NUMBER}-vuln-report.zip"
          ls -l reports

      # 3) Export Component Details V2 -> PDF + SBOM (CycloneDX JSON + SPDX JSON) en un ZIP
      #    Para toda la build (m√°s sencillo que ir imagen por imagen).
      - name: Export Build details (PDF + SBOMs)
        env:
          BUILD_NAME: new-build
          BUILD_NUMBER: ${{ github.run_number }}
        run: |
          # Para builds SIN proyectos: el path suele ser "artifactory-build-info/<build-name>"
          # Si usas Projects, ser√≠a "<ProjectKey>-build-info/<build-name>" (aj√∫stalo si aplica).
          jf xr curl -XPOST /api/v2/component/exportDetails \
            -H "Content-Type: application/json" \
            -d "{
                  \"package_type\": \"build\",
                  \"component_name\": \"${BUILD_NAME}:${BUILD_NUMBER}\",
                  \"path\": \"artifactory-build-info/${BUILD_NAME}\",
                  \"vulnerabilities\": true,
                  \"license\": true,
                  \"operational_risk\": true,
                  \"output_format\": \"pdf\",
                  \"cyclonedx\": true,
                  \"cyclonedx_format\": \"json\",
                  \"spdx\": true,
                  \"spdx_format\": \"json\"
                }" > "reports/${BUILD_NAME}-${BUILD_NUMBER}-export-details.zip"
          ls -l reports

      - name: Upload reports as artifacts
        uses: actions/upload-artifact@v4
        with:
          name: xray-reports-${{ env.BUILD_NAME }}-${{ env.BUILD_NUMBER }}
          path: reports/*

